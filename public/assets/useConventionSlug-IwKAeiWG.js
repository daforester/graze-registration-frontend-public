import{R as d,O as l}from"./index-Cc2MDANl.js";const i=e=>{e.sort((r,t)=>(r.Order?r.Order:0)-(t.Order?t.Order:0));for(let r=0;r<e.length;r++)e[r].Order=r+1;return e},f=(e,r)=>{const t=r.indexOf(e);if(t===0)return;const n=e.Order;e.Order=r[t-1].Order,r[t-1].Order=n,i(r)},m=(e,r)=>{const t=r.indexOf(e);if(t>=r.length-1)return;const n=e.Order;e.Order=r[t+1].Order,r[t+1].Order=n,i(r)},g=e=>(i(e),e),C=e=>(r,t)=>r[e]<t[e]?-1:r[e]>t[e]?1:0,s=new Map;function h(){var c;const e=l(),t=((c=d().params.convention)==null?void 0:c.toString())||"";return{getConvention:async(a=!1)=>{if(!t)return;const o=s.get(`${t}:${a?"true":"false"}`);if(!o||!o.value||o.timestamp<Date.now()-1e3*60*5)try{const u=await e.getConvention(t,a);return s.set(`${t}:${a?"true":"false"}`,{timestamp:Date.now(),value:u}),u}catch{return}return o.value},clearConventionCache:()=>{t&&(s.delete(`${t}:true`),s.delete(`${t}:false`))}}}export{m as a,C as b,g as c,f as m,i as s,h as u};
